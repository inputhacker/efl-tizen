//TIZEN_ONLY(20180607): Restore legacy focus
/* FIXME: This shouldn't be here. */
type list_data_get_func_type: __undefined_type; [[Elementary list data get function type]]
type region_hook_func_type: __undefined_type; [[Elementary region hook function type]]
//

function Efl.Ui.Scrollable_On_Show_Region {
   [[Function pointer for on show region hook]]
   params {
      @in obj: Efl.Canvas.Object; [[Canvas object]]
      @in region: Eina.Rect; [[Showed region]]
   }
};

struct Efl.Ui.Widget_Focus_State {
   [[All relevant fields needed for the current state of focus registeration]]
   manager : Efl.Ui.Focus.Manager; [[The manager where the widget is registered in]]
   parent : Efl.Ui.Focus.Object; [[The parent the widget is using as logical parent]]
   logical : bool; [[$true if this is registered as logical currently]]
}

abstract Efl.Ui.Widget extends Efl.Canvas.Group implements Efl.Access.Object,
                        Efl.Access.Component, Efl.Part, Efl.Ui.Focus.Object,
                        Efl.Ui.Cursor, Efl.Ui.L10n,
                        Efl.Ui.Selection, Efl.Ui.Dnd,
                        //TIZEN_ONLY(20160527): widget: add AtspiAction interface to all widgets
                        Efl.Access.Widget.Action
                        //
{
   [[Efl UI widget abstract class]]
   legacy_prefix: elm_widget;
   //eo_prefix: efl_ui_widget;
   event_prefix: efl_ui_widget;
   data: Efl_Ui_Widget_Data;
   methods {
      @property resize_object @protected {
         [[This is the internal canvas object managed by a widget.

           This property is protected as it is meant for widget implementations
           only, to set and access the internal canvas object. Do use this
           function unless you're implementing a widget.
         ]]
         set {
            [[Sets the new resize object for this widget.]]
         }
         values {
            sobj: Efl.Canvas.Object @nullable;
               [[A canvas object (often a @Efl.Canvas.Layout object).]]
         }
      }
      @property disabled {
         [[Whether the widget is enabled (accepts and reacts to user inputs).

           Each widget may handle the disabled state differently, but overall
           disabled widgets shall not respond to any input events. This is
           $false by default, meaning the widget is enabled.
         ]]
         set {
            [[Enables or disables this widget.

              Disabling a widget will disable all its children recursively,
              but only this widget will be marked as disabled internally.
            ]]
         }
         get {
            [[Returns whether the widget is disabled.

              This will return $true if any widget in the parent hierarchy
              is disabled. Re-enabling that parent may in turn change the
              disabled state of this widget.
            ]]
         }
         values {
            disabled: bool(false); [[$true if the widget is disabled.]]
         }
      }
      @property style {
         [[The widget style to use.

           Styles define different look and feel for widgets, and may provide
           different parts for layout-based widgets. Styles vary from widget
           to widget and may be defined by other themes by means of extensions
           and overlays.

           The style can only be set before @Efl.Object.finalize, which means
           at construction time of the object (inside $efl_add in C).
         ]]
         set @protected {
            [[Can only be called during construction, before finalize.]]
            return: Efl.Ui.Theme_Apply_Result(0);
               [[Whether the style was successfully applied or not, see
                 the values of @Efl.Ui.Theme_Apply_Result for more information.]]
         }
         get {
            [[Returns the current style of a widget.]]
         }
         values {
            style: string;
               [[Name of the style to use. Refer to each widget's documentation
                 for the available style names, or to the themes in use.]]
         }
      }
      widget_event @protected {
         [[Virtual function handling input events on the widget.

           This method should return $true if the event has been processed.
           Only key down, key up and pointer wheel events will be propagated
           through this function.

           It is common for the event to be also marked as processed as in
           @Efl.Input.Event.processed, if this operation was successful. This
           makes sure other widgets will not also process this input event.
         ]]
         params {
            @cref eo_event: Efl.Event;
               [[EO event struct with an Efl.Input.Event as info.]]
            @in source: Efl.Canvas.Object;
               [[Source object where the event originated. Often same as this.]]
         }
         return: bool; [[$true on success, $false otherwise]]
         legacy: null;
      }
      // FIXME: focus_allow? can_focus? focusable?
      @property focus_allow {
         [[The ability for a widget to be focused.

           Unfocusable objects do nothing when programmatically focused. The
           nearest focusable parent object the one really getting focus. Also,
           when they receive mouse input, they will get the event, but not take
           away the focus from where it was previously.

           Note: Objects which are meant to be interacted with by input events
           are created able to be focused, by default. All the others are not.

           This property's default value depends on the widget (eg. a box is
           not focusable, but a button is).
         ]]
         set {
            legacy: elm_widget_can_focus_set;
         }
         get {
            legacy: elm_widget_can_focus_get;
         }
         values {
            can_focus: bool; [[Whether the object is focusable.]]
         }
      }
      @property widget_parent @protected {
         [[The internal parent of this widget.

           @Efl.Ui.Widget objects have a parent hierarchy that may differ slightly
           from their @Efl.Object or @Efl.Canvas.Object hierarchy. This is
           meant for internal handling.

           See also @.widget_top.
         ]]
         set {}
         get {
            legacy: elm_widget_parent_get; /* internal in legacy */
         }
         values {
            parent: Efl.Ui.Widget @nullable; [[Widget parent object]]
         }
      }
      @property widget_top {
         [[Root widget in the widget hierarchy.

           This returns the top widget, in terms of widget hierarchy. This is
           usually a window (@Efl.Ui.Win). This function walks the list of
           @.widget_parent.

           If this widget has no parent (in terms of widget hierarchy) this
           will return $null.

           Note: This may not be a display manager window in case of nested
           canvases. If a "real" window is required, then you might want to
           verify that the returned object is a @Efl.Ui.Win_Inlined, and then
           get @Efl.Ui.Win_Inlined.inlined_parent to find an object in the
           master window.

           See also @.widget_parent.
         ]]
         get {
            legacy: elm_widget_top_get; /* internal in legacy */
         }
         values {
            top: Efl.Ui.Widget; [[Top widget, usually a window.]]
         }
      }

      /* Accessibility */
      @property access_info {
         [[Accessibility information.

           This is a replacement string to be read by the accessibility
           text-to-speech engine, if accessibility is enabled by configuration.
           This will take precedence over the default text for this object,
           which means for instance that the label of a button won't be read
           out loud, instead $txt will be read out.
         ]]
         values {
            txt: string @nullable; [[Accessibility text description.]]
         }
      }
      on_access_activate @protected @beta {
         [[Hook function called when widget is activated through accessibility.

           This meant to be overridden by subclasses to support accessibility.
           This is an unstable API.
         ]]
         params {
            @in act: Efl.Ui.Activate; [[Type of activation.]]
         }
         return: bool; [[$true on success, $false otherwise]]
         legacy: null; /* FIXME: legacy API does extra work */
      }
      on_access_update @protected @beta {
         [[Hook function called when accessibility is changed on the widget.

           This meant to be overridden by subclasses to support accessibility.
           This is an unstable API.
         ]]
         params {
            @in enable: bool; [[$true if accessibility is enabled.]]
         }
         legacy: null; /* FIXME: legacy API does extra work */
      }

      //TIZEN_ONLY(20160822): When atspi mode is dynamically switched on/off,
      //register/unregister access objects accordingly.
      // TIZEN_ONLY(20170516): connect to at-spi dbus based on org.a11y.Status.IsEnabled property
      screen_reader {
         [['Virtual' function on the widget being set screen reader.]]
         params {
            @in is_screen_reader: bool;
         }
         legacy: null;
      }
      //
      //TIZEN_ONLY(20170621) handle atspi proxy connection at runtime
      atspi {
         [['Virtual' function on the widget being set atspi.]]
         params {
            @in is_atspi: bool;
         }
         legacy: null;
      }
      //
      /* Internal hooks. */
      widget_sub_object_add @protected {
         [[Virtual function handling sub objects being added.

           Sub objects can be any canvas object, not necessarily widgets.

           See also @.widget_parent.
         ]]
         params {
            @in sub_obj: Efl.Canvas.Object;
               [[Sub object to be added. Not necessarily a widget itself.]]
         }
         return: bool; [[Indicates if the operation succeeded.]]
         legacy: elm_widget_sub_object_add;
      }
      widget_sub_object_del @protected {
         [[Virtual function handling sub objects being removed.

           Sub objects can be any canvas object, not necessarily widgets.

           See also @.widget_parent.
         ]]
         params {
            @in sub_obj: Efl.Canvas.Object;
               [[Sub object to be removed. Should be a child of this widget.]]
         }
         return: bool; [[Indicates if the operation succeeded.]]
         legacy: elm_widget_sub_object_del;
      }
      @property orientation_mode {
         [[Whether the widget's automatic orientation is enabled or not.

           Orientation mode is used for widgets to change their style or send
           signals based on the canvas rotation (i.e. the window orientation).
           If the orientation mode is enabled, the widget will emit signals
           such as "elm,state,orient,N" where $N is one of 0, 90, 180, 270,
           depending on the window orientation. Such signals may be handled by
           the theme in order to provide a different look for the widget based
           on the canvas orientation.

           By default orientation mode is enabled.

           See also @.on_orientation_update.
         ]]
         values {
            mode: Efl.Ui.Widget_Orientation_Mode(Efl.Ui.Widget_Orientation_Mode.default);
               [[How window orientation should affect this widget.]]
         }
      }
      on_orientation_update @protected {
         [[Virtual function handling canvas orientation changes.

           This method will be called recursively from the top widget (the
           window) to all the children objects whenever the window rotation
           is changed. The given $rotation will be one of 0, 90, 180, 270 or
           the special value -1 if @.orientation_mode is $disabled.

           If @.orientation_mode is $default, the widget implementation will
           emit the signal "elm,state,orient,$R" will be emitted (where $R is
           the rotation angle in degrees).

           Note: This function may be called even if the orientation has not
           actually changed, like when a widget needs to be reconfigured.

           See also @.orientation_mode.
         ]]
         params {
            rotation: int; [[Orientation in degrees: 0, 90, 180, 270 or -1 if
               @.orientation_mode is $disabled.]]
         }
      }
      on_disabled_update @protected {
         [[Virtual function called when the widget becomes disabled.

           This may be triggered even if this widget is not disabled, as the
           parent widget could be disabled and propagate its state.
         ]]
         params {
            disabled: bool; [[The new value of @.disabled.]]
         }
         return: bool; [[Indicates if the operation succeeded.]]
      }
      theme_apply @protected {
         [[Virtual function called when the widget needs to re-apply its theme.

           This may be called when the object is first created, or whenever
           the widget is modified in any way that may require a reload of the
           theme. This may include but is not limited to scale, theme, or
           mirrored mode changes.

           Note: even widgets not based on layouts may override this method
           to handle widget updates (scale, mirrored mode, etc...).
         ]]
         return: Efl.Ui.Theme_Apply_Result; [[Indicates success, and if the current
                                       theme or default theme was used.]]
      }

      /* Scroll API. */
      @property on_show_region_hook @protected {
         [[Hook function called when the @.show_region is changed.

           See also @.show_region.
         ]]
         set {}
         values {
            func: Efl.Ui.Scrollable_On_Show_Region @nullable; [[Region hook function]]
         }
      }
      @property show_region @protected {
         [[Region inside the widget to show.

           See also @.on_show_region_hook.
         ]]
         set {
            [[Request parent scrollers to pan around so that this region
              of the widget becomes visible.

              If $force is $true this will trigger scroller changes and
              the @.on_show_region_hook to be called even if the region is
              unchanged.
            ]]
            values {
               region: Eina.Rect; [[The region to show.]]
               force: bool; [[Set to $true to force show even if unchanged.]]
            }
         }
         get {
            [[Returns the current region to show.]]
            values {
               region: Eina.Rect; [[The region to show.]]
            }
         }
      }
      /* FIXME: Scroll API. Not sure how those APIs should be exposed with
       * the new scrollable API. */
      scroll_hold_push {
         [[Push scroll hold]]
      }
      scroll_hold_pop {
         [[Pop scroller hold]]
      }
      scroll_freeze_push {
         [[Push scroller freeze]]
      }
      scroll_freeze_pop {
         [[Pop scroller freeze]]
      }

      /* Region of interest */
      @property interest_region @protected {
         [[Region of interest inside this widget, that should be given
           priority to be visible inside a scroller.

           When this widget or one of its subwidgets is given focus, this
           region should be shown, which means any parent scroller should
           attempt to display the given area of this widget. For instance, an
           entry given focus should scroll to show the text cursor if that
           cursor moves. In this example, this region defines the relative
           geometry of the cursor within the widget.

           Note: The region is relative to the top-left corner of the widget,
           i.e. X,Y start from 0,0 to indicate the top-left corner of the
           widget. W,H must be greater or equal to 1 for this region to be
           taken into account, otherwise it is ignored.

           See also @.interest_region_mode
         ]]
         get {
            legacy: elm_widget_focus_region_get;
         }
         values {
            region: Eina.Rect;
               [[The relative region to show. If width or height is <= 0 it
                 will be ignored, and no action will be taken.]]
         }
      }
      @property interest_region_mode {
         [[Defines how @.show_region should be calculated.

           It is up to the implementation of @.show_region.get to take this
           value into account (or ignore it).
         ]]
         get {
            legacy: elm_widget_focus_region_show_mode_get;
         }
         set {
            legacy: elm_widget_focus_region_show_mode_set;
         }
         values {
            mode: Efl.Ui.Interest_Region_Mode;
               [[Whether to show a specific item or the widget as a whole.]]
         }
      }

      /* Focus highlight (visual focus rectangle) properties */
      @property focus_highlight_geometry @protected {
         [[The rectangle region to be highlighted on focus.

           This is a rectangle region where the focus highlight should be
           displayed.
         ]]
         get {
            [[This is a read-only property.]]
         }
         values {
            region: Eina.Rect; [[The rectangle area.]]
         }
      }
      @property focus_highlight_enabled {
         [[Whether focus highlight is enabled or not.

           As of EFL 1.21 focus highlight properties apply to a single window,
           not a single widget. As a consequence, calls to this function may
           be forwarded to the parent window. Future versions of EFL may
           implement widget-specific focus highlight properties.

           See also @.widget_top.
           See also @.focus_highlight_style.
           See also @.focus_highlight_animate.
         ]]
         set {
            [[Set the enabled status for the focus highlight in a window.

              This function will enable or disable the focus highlight,
              regardless of the global setting for it.
            ]]
         }
         get {
            [[Get the enabled value of the focus highlight for this window.]]
         }
         values {
            enabled: bool; [[The enabled value for the highlight.]]
         }
      }
      @property focus_highlight_style {
         [[Control the widget focus highlight style.

           If $style is $null, the default will be used.

           As of EFL 1.21 focus highlight properties apply to a single window,
           not a single widget. As a consequence, calls to this function may
           be forwarded to the parent window. Future versions of EFL may
           implement widget-specific focus highlight properties.

           See also @.widget_top.
           See also @.focus_highlight_enabled.
           See also @.focus_highlight_animate.
         ]]
         set {
            /* FIXME: This is async... success here means nothing. */
            return: bool; [[$true on success, $false otherwise.]]
         }
         get {
         }
         values {
            style: string @nullable; [[The name of the focus highlight style.]]
         }
      }
      @property focus_highlight_animate {
         [[Whether focus highlight should animate or not.

           As of EFL 1.21 focus highlight properties apply to a single window,
           not a single widget. As a consequence, calls to this function may
           be forwarded to the parent window. Future versions of EFL may
           implement widget-specific focus highlight properties.

           See also @.widget_top.
           See also @.focus_highlight_style.
           See also @.focus_highlight_enabled.
         ]]
         set {
            [[Set the animate status for the focus highlight for this window.

              This function will enable or disable the animation of focus
              highlight.
            ]]
         }
         get {
            [[Get the animate value of the focus highlight for this window.]]
         }
         values {
            animate: bool; [[The enabled value for the highlight animation.]]
         }
      }
       //TIZEN_ONLY(20160726): add API elm_object_part_access_object_get
       part_access_object_get @const {
         [[Get the access object of given part of the widget.
           @since 1.18]]
         return: Efl.Canvas.Object;
         params {
            @in part: string; [[The object's part name to get access object]]
         }
       }
       //
      //TIZEN_ONLY(20180607): Restore legacy focus
      newest_focus_order_get @const {
          [[Get newest focus in order]]
         return: Efl.Canvas.Object; [[Handle to focused widget]]
         params {
            @out newest_focus_order: uint; [[Newest focus order]]
            @in can_focus_only: bool; [[$true only us widgets which can focus, $false otherweise]]
         }
      }
      @property focus_order @beta {
          [[Focus order property]]
          get {
             return: uint; [[FIXME]]
          }
       }
       focus_next_object_set @beta {
          [[Set the next object with specific focus direction.

            @since 1.8]]
          params {
             @in next: Efl.Canvas.Object @nullable; [[Focus next object]]
             @in dir: Efl.Ui.Focus.Direction; [[Focus direction]]
          }
       }
       focus_next_object_get @const @beta {
          [[Get the next object with specific focus direction.

            @since 1.8]]
          return: Efl.Canvas.Object; [[Focus next object]]
          params {
             @in dir: Efl.Ui.Focus.Direction; [[Focus direction]]
          }
       }
       focus_next_item_set @beta {
          [[Set the next object item with specific focus direction.

            @since 1.16]]
          params {
             @in next_item: Elm.Widget.Item @nullable; [[Focus next object item]]
             @in dir: Efl.Ui.Focus.Direction; [[Focus direction]]
          }
       }
       focus_next_item_get @const @beta {
          [[Get the next object item with specific focus direction.

            @since 1.16]]
          return: Elm.Widget.Item; [[Focus next object item]]
          params {
             @in dir: Efl.Ui.Focus.Direction; [[Focus direction]]
          }
       }
       focus_tree_unfocusable_handle {
          [[Handle focus tree unfocusable]]
       }
       focus_custom_chain_prepend @beta {
          [[Prepend object to custom focus chain.

            Note: If @"relative_child" equal to $null or not in custom chain,
            the object will be added in begin.

            Note: On focus cycle, only will be evaluated children of this container.]]
          params {
             @in child: Efl.Canvas.Object; [[The child to be added in custom chain.]]
             @in relative_child: Efl.Canvas.Object @optional; [[The relative object to position the child.]]
          }
       }
       focus_cycle @beta {
          [[Give focus to next object with specific focus direction in
            object tree.]]
          params {
             @in dir: Efl.Ui.Focus.Direction; [[Direction to move the focus.]]
          }
       }
       focus_direction @pure_virtual @beta {
          [['Virtual' function handling passing focus to sub-objects given a direction, in degrees.]]
          params {
             @in base: const(Efl.Canvas.Object); [[Base object]]
             @in degree: double; [[Degree]]
             @out direction: Efl.Canvas.Object; [[Direction]]
             @out direction_item: Elm.Widget.Item; [[Direction item]]
             @out weight: double; [[Weight]]
          }
          return: bool; [[$true on success, $false otherwise]]
       }
       focus_next_manager_is @beta {
          [['Virtual' function which checks if handling of passing focus to sub-objects is supported by widget.]]
          return: bool; [[$true on success, $false otherwise]]
       }
       focus_list_direction_get @const {
          [[Get focus list direction]]
          return: bool; [[$true on success, $false otherwise]]
          params {
             @in base: const(Efl.Canvas.Object); [[Base object]]
             @in items: const(list<Efl.Object>); [[Item list]]
             @in list_data_get: void_ptr; [[Data get function]]
             @in degree: double; [[Degree]]
             @out direction: Efl.Canvas.Object; [[Direction]]
             @out direction_item: Elm.Widget.Item; [[Direction item]]
             @out weight: double; [[Weight]]
          }
       }
       focused_object_clear @beta {
          [[Clear focused object]]
       }
       focus_direction_go @beta {
          [[Go in focus direction]]
          return: bool; [[$true on success, $false otherwise]]
          params {
             @in degree: double; [[Degree]]
          }
       }
       focus_next_get @const @beta {
          [[Get next focus item]]
          return: bool; [[$true on success, $false otherwise]]
          params {
             @in dir: Efl.Ui.Focus.Direction; [[Focus direction]]
             @out next: Efl.Canvas.Object; [[Next object]]
             @out next_item: Elm.Widget.Item; [[Next item]]
          }
       }
       focus_restore @beta {
          [[Restore the focus state of the sub-tree.

          This API will restore the focus state of the sub-tree to the latest
          state. If a sub-tree is unfocused and wants to get back to the latest
          focus state, this API will be helpful.]]
       }
       focus_custom_chain_unset @beta {
          [[Unset a custom focus chain on a given Elementary widget.

            Any focus chain previously set is removed entirely after this call.]]
       }
       focus_steal @beta {
          [[Steal focus]]
          params {
             @in item: Elm.Widget.Item @nullable; [[Widget to steal focus from]]
          }
       }
       focus_hide_handle @beta {
          [[Handle hide focus]]
       }
       focus_next @pure_virtual @beta {
          [['Virtual' function handling passing focus to sub-objects.]]
          params {
             @in dir: Efl.Ui.Focus.Direction; [[Focus direction]]
             @out next: Efl.Canvas.Object; [[Next object]]
             @out next_item: Elm.Widget.Item; [[Next item]]
          }
          return: bool; [[$true on success, $false otherwise]]
       }
       focus_list_next_get @const {
           [[Get next item in focus list]]
          return: bool; [[$true on success, $false otherwise]]
          params {
             @in items: const(list<Efl.Object>); [[Item list]]
             @in list_data_get: void_ptr; [[Function type]]
             @in dir: Efl.Ui.Focus.Direction; [[Focus direction]]
             @out next: Efl.Canvas.Object; [[Next object]]
             @out next_item: Elm.Widget.Item; [[Next item]]
          }
       }
       focus_mouse_up_handle {
           [[Handle focus mouse up]]
          legacy: null;
       }
       focus_direction_get @const @beta {
          [[Get focus direction]]
          return: bool; [[$true on success, $false otherwise]]
          params {
             @in base: const(Efl.Canvas.Object); [[Base]]
             @in degree: double; [[Degree]]
             @out direction: Efl.Canvas.Object; [[Direction]]
             @out direction_item: Elm.Widget.Item; [[Direction item]]
             @out weight: double; [[Weight]]
          }
       }
       focus_disabled_handle @beta {
          [[Handle disable widget focus]]
       }
       focus_custom_chain_append @beta {
          [[Append object to custom focus chain.

            Note: If @"relative_child" equal to $null or not in custom chain,
            the object will be added in end.

            Note: On focus cycle, only will be evaluated children of this container.]]
          params {
             @in child: Efl.Canvas.Object; [[The child to be added in custom chain.]]
             @in relative_child: Efl.Canvas.Object @optional; [[The relative object to position the child.]]
          }
      }
      focus_reconfigure @beta {
          [[@since 1.18]]
       }
      @property focus_custom_chain @beta {
          [[A custom chain of objects to pass focus.

            Note: On focus cycle, only will be evaluated children of this container.]]
          set {
             [[This function overwrites any previous custom focus chain within
               the list of objects. The previous list will be deleted and this list
               will be managed by elementary. After it is set, don't modify it.]]
             values {
                objs: list<Efl.Canvas.Object>; [[Chain of objects to pass focus]]
             }
          }
          get {
             values {
                objs: const(list<Efl.Canvas.Object>); [[Chain of objects]]
             }
          }
       }
      @property focused_object @beta {
          [[Current focused object in object tree.]]
          get {
             return: Efl.Canvas.Object; [[Current focused or $null, if there is no focused object.]]
          }
       }
      focus_direction_manager_is @protected {
          [[Virtual function which checks if this widget can handle passing
            focus to sub-object, in a given direction.]]
          return: bool; [[$true on success, $false otherwise]]
          legacy: null;
      }
      //END
      @property focus_move_policy @beta {
         [[The widget's focus move policy.]]
         values {
            policy: Efl.Ui.Focus.Move_Policy; [[Focus move policy]]
         }
      }
      @property focus_move_policy_automatic @beta {
         [[Control the widget's focus_move_policy mode setting.

           @since 1.18]]
         values {
            automatic: bool; [[$true to follow system focus move policy change,
                               $false otherwise]]
         }
      }

      /* FIXME: No more items in EO API */
      @property focused_item @beta {
         get {
            [[Get the focused widget item.]]
            return: Elm.Widget.Item; [[Focused item]]
         }
      }

      /* Focus Manager API */
      focus_state_apply @protected {
         [[Register focus with the given configuration.

           The implementation can feel free to change the logical flag as it
           wants, but other than that it should strictly keep the configuration.

           The implementation in elm.widget updates the current state into what
           is passed as configured state, respecting manager changes,
           registeration and unregistration based on if it should be registered
           or unregistered.

           A manager field that is $null means that the widget should not or was
           not registered.
         ]]
         params {
            @in current_state : Efl.Ui.Widget_Focus_State;
               [[The focus manager to register with.]]
            @inout configured_state : Efl.Ui.Widget_Focus_State;
               [[The evaluated Focus state that should be used.]]
            @in redirect : Efl.Ui.Widget;
               [[A redirect that will be set by the elm.widget implementation.]]
         }
         return: bool; [[Returns whether the widget is registered or not.]]
      }
   }
   parts {
      shadow: Efl.Ui.Widget_Part_Shadow;
      background: Efl.Ui.Widget_Part_Bg;
   }
   implements {
      class.constructor;
      Efl.Object.constructor;
      Efl.Object.finalize;
      Efl.Object.destructor;
      Efl.Object.provider_find;
      Efl.Object.debug_name_override;
      Efl.Gfx.Color.color { set; }
      Efl.Gfx.Entity.visible { set; }
      Efl.Gfx.Entity.position { set; }
      Efl.Gfx.Entity.size { set; }
      Efl.Gfx.Entity.scale { set; get; }
      Efl.Canvas.Object.clip { set; }
      Efl.Canvas.Object.no_render { set; }
      Efl.Canvas.Object.is_frame_object { set; }
      Efl.Canvas.Group.group_calculate;
      Efl.Canvas.Group.group_member_del;
      Efl.Canvas.Group.group_member_add;
      Efl.Access.Object.i18n_name { get; }
      Efl.Access.Object.state_set { get; }
      Efl.Access.Object.access_children { get; }
      Efl.Access.Object.attributes { get; }
      Efl.Access.Component.focus_grab;
      Efl.Ui.Focus.Object.focus_manager { get; }
      Efl.Ui.Focus.Object.focus_parent { get; }
      Efl.Ui.Focus.Object.focus_geometry { get; }
      Efl.Ui.Focus.Object.focus { set; }
      Efl.Ui.I18n.mirrored { get; set; }
      Efl.Ui.I18n.mirrored_automatic { get; set; }
      Efl.Ui.Cursor.cursor { get; set; }
      Efl.Ui.Cursor.cursor_style { get; set; }
      Efl.Ui.Cursor.cursor_theme_search_enabled { get; set; }
      Efl.Ui.Focus.Object.on_focus_update;
      Efl.Ui.L10n.translation_update; [[This implements the calls to $gettext() and $text_set().]]
      Efl.Part.part_get; [[Returns @Efl.Ui.Widget_Part.]]

      //TIZEN_ONLY(20161111) add widget/widget_item description get/set
      Efl.Access.Object.description { set; get; }
      //

      //TIZEN_ONLY(20150731) : add i18n support for name and description
      Efl.Access.Object.translation_domain { set; get;}
      //

      //TIZEN_ONLY(20150709) : atspi relations api
      Efl.Access.Object.relation_set { get;}
      Efl.Access.Object.relationship_append;
      Efl.Access.Object.relationship_remove;
      Efl.Access.Object.relationships_clear;
      //

      //TIZEN_ONLY(20171108): bring HIGHLIGHT related changes
      Efl.Access.Component.accessible_at_point_get;
      Efl.Access.Component.highlight_grab;
      Efl.Access.Component.highlight_clear;
      //

      //TIZEN_ONLY(20160726): add API elm_atspi_accessible_can_highlight_set/get
      Efl.Access.Object.can_highlight { get; set; }
      //

      //TIZEN_ONLY(20160527): widget: add AtspiAction interface to all widgets
      Efl.Access.Widget.Action.elm_actions { get; }
      //

      /***********************************************************
       * TIZEN_ONLY(20180117): Override Paragraph Direction APIs *
       ***********************************************************/
      Efl.Canvas.Object.paragraph_direction { set; }
      /*******
       * END *
       *******/
   }
   events {
      moved: Efl.Object; [[Called when widget moved]]
      language,changed: void; [[Called when widget language changed]]
      access,changed: void; [[Called when accessibility changed]]

      // TIZEN_ONLY(20161018): add highlighted/unhighlighted signal for atspi
      atspi,highlighted: void;
      atspi,unhighlighted: void;
      //
   }
}
