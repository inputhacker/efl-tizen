import edje_types;

// FIXME: This EO doc needs a direct link to the "edcref" doc

class Efl.Canvas.Layout (Efl.Canvas.Group, Efl.File, Efl.Container, Efl.Part,
                         Efl.Observer, Efl.Ui.Base, Efl.Layout.Calc,
                         Efl.Layout.Signal, Efl.Layout.Group,
                         Efl.Player, Efl.Gfx.Color_Class, Efl.Gfx.Text_Class,
                         Efl.Gfx.Size_Class)
{
   [[Edje object class]]
   legacy_prefix: edje_object;
   data: Edje;
   methods {
      @property animation {
         [[Whether this object is animating or not.

           This property indicates whether animations are stopped or not.
           Animations here refer to transitions between states.

           If animations are disabled, transitions between states (as
           defined in EDC) are then instantaneous. This is conceptually similar
           to setting the @Efl.Player.play_speed to an infinitely high
           value.
         ]]
         get {
            [[Get the current state of animation, $true by default.]]
         }
         set {
            [[Start or stop animating this object.]]
         }
         values {
            on: bool; [[The animation state, $true by default.]]
         }
      }

      access_part_iterate @beta {
         [[Iterates over all accessibility-enabled part names.]]
         legacy: null;
         return: iterator<string> @owned; [[Part name iterator]]
      }

      /* TEXT PART APIS BEGIN ---------------------------------------------- */
      @property item_provider {
         set {
            [[Sets the function that provides item objects for named items in an edje entry text

              Item objects may be deleted any time by Edje, and will be deleted when the
              Edje object is deleted (or file is set to a new file).]]
         }
         values {
            func: Edje.Item_Provider_Cb; [[The function to call (or $null to disable) to get item objects]]
            data: void_ptr; [[The data pointer to pass to the func callback]]
         }
      }
      /* TEXT PART APIS END ------------------------------------------------ */

      @property seat {
         get {
            [[Returns the seat device given its Edje's name.

              Edje references seats by a name that differs from Evas.
              Edje naming follows a incrementional convention: first
              registered name is "seat1", second is "seat2", differently
              from Evas.

              @since 1.19]]

            return: Efl.Input.Device; [[The seat device or $null if not found.]]
         }
         keys {
            name: stringshare; [[The name's character string.]]
         }
      }
      @property seat_name {
         get {
            [[Gets the name given to a set by Edje.

              Edje references seats by a name that differs from Evas.
              Edje naming follows a incrementional convention: first
              registered name is "seat1", second is "seat2", differently
              from Evas.

              @since 1.19]]

            return: stringshare; [[The name's character string or $null if not found.]]
         }
         keys {
            device: Efl.Input.Device; [[The seat device]]
         }
      }
      /***********************************************************************************
       * TIZEN_ONLY_FEATURE: API for handling text properties of Edje                    *
       ***********************************************************************************/
      @property part_text_min_policy {
         set {
            [[Sets the object text min calculation policy.

              Do not use this API without understanding whats going on.
              It is made for internal usage.

              \@if MOBILE \@since_tizen 3.0
              \@elseif WEARABLE \@since_tizen 3.0
              \@endif
              \@internal
            ]]
            return: bool; [[$true on success, or $false on error]]
         }
         get {
            [[Gets the object text min calculation policy.

              Do not use this API without understanding whats going on.
              It is made for internal usage.

              \@if MOBILE \@since_tizen 3.0
              \@elseif WEARABLE \@since_tizen 3.0
              \@endif
              \@internal
            ]]
            return: bool; [[$true on success, or $false on error]]
         }
         keys {
            part: string; [[The part name]]
            state_name: string; [[The state name]]
         }
         values {
            min_x: bool; [[The min width policy]]
            min_y: bool; [[The min height policy]]
         }
      }
      @property part_text_valign {
         set {
            [[Sets the valign for text.

              Do not use this API without understanding whats going on.
              It is made for internal usage.
              \@internal
            ]]
            return: bool; [[$true, on success or $false, on error]]
         }
         get {
            [[Gets the valign for text.

              Do not use this API without understanding whats going on.
              It is made for internal usage.
              \@internal
            ]]
         }
         keys {
            part: string; [[The part name]]
         }
         values {
            valign: double; [[The valign 0.0~1.0. -1.0 for respect EDC's align value.]]
         }
      }
      /*******
       * END *
       *******/
   }
   implements {
      Efl.Gfx.visible { set; }
      Efl.Gfx.position { set; }
      Efl.Gfx.size { set; }
      Efl.Object.constructor;
      Efl.Object.debug_name_override;
      Efl.Canvas.Object.no_render { set; }
      Efl.Canvas.Object.paragraph_direction { set; }
      Efl.Gfx.Color_Class.color_class { get; set; }
      Efl.Gfx.Color_Class.color_class_description { get; }
      Efl.Gfx.Color_Class.color_class_del;
      Efl.Gfx.Color_Class.color_class_clear;
      Efl.Gfx.Text_Class.text_class { get; set; }
      Efl.Gfx.Text_Class.text_class_del;
      Efl.Gfx.Size_Class.size_class { get; set; }
      Efl.Gfx.Size_Class.size_class_del;
      Efl.Canvas.Group.group_calculate;
      Efl.Layout.Calc.calc_auto_update_hints { get; set; }
      Efl.Layout.Calc.calc_size_min;
      Efl.Layout.Calc.calc_parts_extends;
      Efl.Layout.Calc.calc_freeze;
      Efl.Layout.Calc.calc_thaw;
      Efl.Layout.Calc.calc_force;
      Efl.Layout.Group.group_size_min { get; }
      Efl.Layout.Group.group_size_max { get; }
      Efl.Layout.Group.group_data { get; }
      Efl.Layout.Signal.message_send;
      Efl.Layout.Signal.signal_callback_add;
      Efl.Layout.Signal.signal_callback_del;
      Efl.Layout.Signal.signal_emit;
      Efl.Layout.Signal.signal_process;
      Efl.Ui.Base.mirrored { set; get; }
      Efl.Ui.Base.language { set; get; }
      Efl.Gfx.scale { set; get; }
      Efl.File.load_error { get; }
      Efl.File.mmap { get; set; }
      Efl.Container.content_remove;
      Efl.Part.part; [[Returns @Efl.Canvas.Layout.Part.]]
      Efl.Observer.update;
      Efl.Player.playable { get; }
      Efl.Player.play { get; set; }
      Efl.Player.play_speed { get; set; }
   }
}
