static const char vertex_shader[] =
   "#ifdef GL_ES\n"
   "precision mediump float;\n"
   "#endif\n"
   "attribute vec4 vertex;\n"
   "attribute vec2 tex_coord;\n"
   "uniform mat4 mvp;\n"
   "uniform vec4 pos;\n"
   "void main()\n"
   "{\n"
   "   vec4 new_vert = pos + vertex;\n"
   "   gl_Position = mvp * new_vert;\n"
   "}\n";

static const char fragment_shader[] =
   "#ifdef GL_ES\n"
   "precision mediump float;\n"
   "# endif\n"
   "uniform vec4 color;\n"
   "void main()\n"
   "{\n"
   "   gl_FragColor = color;\n"
   "}\n";

static const char tex_vertex_shader[] =
   "#ifdef GL_ES\n"
   "precision mediump float;\n"
   "#endif\n"
   "attribute vec4 vertex;\n"
   "attribute vec2 tex_coord;\n"
   "uniform mat4 mvp;\n"
   "uniform vec4 pos;\n"
   "varying vec2 v_tex_coord;\n"
   "void main()\n"
   "{\n"
   "   vec4 new_vert = pos + vertex;\n"
   "   gl_Position = mvp * new_vert;\n"
   "   v_tex_coord = tex_coord;\n"
   "}\n";

static const char tex_fragment_shader[] =
   "#ifdef GL_ES\n"
   "precision mediump float;\n"
   "# endif\n"
   "varying vec2 v_tex_coord;\n"
   "uniform sampler2D texture;\n"
   "uniform vec4 color;\n"
   "void main()\n"
   "{\n"
   "   gl_FragColor = color * texture2D(texture, v_tex_coord);\n"
   "}\n";

static const char linear_gradient_vertex_shader[] =
   "#ifdef GL_ES\n"
   "precision mediump float;\n"
   "#endif\n"
   "attribute vec4 vertex;\n"
   "attribute vec2 tex_coord;\n"
   "uniform mat4 mvp;\n"
   "uniform vec4 pos;\n"
   "uniform vec2 half_viewport_size; \n"
   "uniform vec3 linear_data; \n"
   "varying float index; \n"
   "void main() \n"
   "{ \n"
   "   vec4 new_vert = pos + vertex;\n"
   "   gl_Position = mvp * new_vert;\n"
   "   vec2 viewport_coords = (gl_Position.xy + 1.0) * half_viewport_size; \n"
   "   vec3 hTexCoords = vec3(viewport_coords, 1); \n"
   "   index = (dot(linear_data.xy, hTexCoords.xy) * linear_data.z); \n"
   "}\n";

static const char linear_gradient_fragment_shader[] =
   "#ifdef GL_ES\n"
   "precision mediump float;\n"
   "# endif\n"
   "uniform sampler2D texture;\n"
   "varying float index; \n"
   "void main()\n"
   "{\n"
   "vec2 val = vec2(index, 0.5); \n"
   "gl_FragColor = texture2D(texture, val);\n"
   "}\n";


 // Radial Gradient Brush
static const char radial_gradient_vertex_shader[] =
   "#ifdef GL_ES\n"
   "precision mediump float;\n"
   "#endif\n"
   "attribute vec4 vertex;\n"
   "attribute vec2 tex_coord;\n"
   "uniform mat4   mvp;\n"
   "uniform vec4   pos;\n"
   "uniform vec2   half_viewport_size; \n"
   "uniform vec2   fmp; \n"
   "uniform vec3   bradius; \n"
   "varying float  b; \n"
   "varying vec2   A; \n"
   "void main() \n"
   "{ \n"
   "   vec4 new_vert = pos + vertex;\n"
   "   gl_Position = mvp * new_vert;\n"
   "   vec2 viewport_coords = (gl_Position.xy + 1.0) * half_viewport_size; \n"
   "   vec3 hTexCoords = vec3(viewport_coords, 1); \n"
   "   A = hTexCoords.xy; \n"
   "   b = bradius.x + 2.0 * dot(A, fmp); \n"
   "}\n";

  static const char radial_gradient_fragment_shader[] =
   "#ifdef GL_ES\n"
   "precision mediump float;\n"
   "# endif\n"
   "uniform sampler2D texture;\n"
   "uniform float     fmp2_m_radius2; \n"
   "uniform float     inverse_2_fmp2_m_radius2; \n"
   "uniform float     sqrfr; \n"
   "uniform vec3      bradius; \n"
   "varying float     b; \n"
   "varying vec2      A; \n"
   "void main()\n"
   "{\n"
   "   float c = sqrfr - dot(A, A); \n"
   "   float det = b*b - 4.0*fmp2_m_radius2*c; \n"
   "   vec4 result = vec4(0.0); \n"
   "   if (det >= 0.0) \n"
   "     { \n"
   "        float detSqrt = sqrt(det); \n"
   "        float w = max((-b - detSqrt) * inverse_2_fmp2_m_radius2, (-b + detSqrt) * inverse_2_fmp2_m_radius2); \n"
   "        if (bradius.y + w * bradius.z >= 0.0) \n"
   "          result = texture2D(texture, vec2(w, 0.5)); \n"
   "     } \n"
   "   gl_FragColor = result;\n"
   "}\n";
