interface @beta Efl.Pack_Linear extends Efl.Pack
{
   [[API for containers ]]
   eo_prefix: efl_pack;
   methods {
      pack_begin {
         [[Prepend an object at the beginning of this container.

           This is the same as @.pack_at($subobj, 0).

           When this container is deleted, it will request deletion of the
           given $subobj. Use @Efl.Pack.unpack to remove $subobj from this
           container without deleting it.
         ]]
         params {
            @in subobj: Efl.Gfx.Entity; [[Item to pack at the beginning.]]
         }
         return: bool; [[$false if $subobj could not be packed.]]
      }
      pack_end {
         [[Append item at the end of this container.

           This is the same as @.pack_at($subobj, -1).

           When this container is deleted, it will request deletion of the
           given $subobj. Use @Efl.Pack.unpack to remove $subobj from this
           container without deleting it.
         ]]
         params {
            @in subobj: Efl.Gfx.Entity; [[Item to pack at the end.]]
         }
         return: bool; [[$false if $subobj could not be packed.]]
      }
      pack_before {
         [[Prepend item before other sub object.

           When this container is deleted, it will request deletion of the
           given $subobj. Use @Efl.Pack.unpack to remove $subobj from this
           container without deleting it.
         ]]
         params {
            @in subobj: Efl.Gfx.Entity; [[Item to pack before $existing.]]
            @in existing: const(Efl.Gfx.Entity); [[Item to refer to.]]
         }
         return: bool; [[$false if $existing could not be found or $subobj
                         could not be packed.]]
      }
      pack_after {
         [[Append item after other sub object.

           When this container is deleted, it will request deletion of the
           given $subobj. Use @Efl.Pack.unpack to remove $subobj from this
           container without deleting it.
         ]]
         params {
            @in subobj: Efl.Gfx.Entity; [[Item to pack after $existing.]]
            @in existing: const(Efl.Gfx.Entity); [[Item to refer to.]]
         }
         return: bool; [[$false if $existing could not be found or $subobj
                         could not be packed.]]
      }
      pack_at {
          [[Inserts $subobj BEFORE the item at position $index.

            $index ranges from -$count to $count-1, where positive numbers go
            from first item (0) to last item ($count-1), and negative numbers go
            from last item (-1) to first item (-$count). Where $count is
            the number of items currently in the container.

            If $index is less than -$count, it will trigger @.pack_begin($subobj)
            whereas $index greater than $count-1 will trigger @.pack_end($subobj).

            When this container is deleted, it will request deletion of the
            given $subobj. Use @Efl.Pack.unpack to remove $subobj from this
            container without deleting it.
          ]]
          params {
             @in subobj: Efl.Gfx.Entity; [[Item to pack.]]
             @in index:  int; [[Index of item to insert BEFORE.
                                Valid range is -$count to ($count-1).
                              ]]
          }
          return: bool; [[$false if $subobj could not be packed.]]
      }
      pack_content_get {
         [[Content at a given $index in this container.

           $index ranges from -$count to $count-1, where positive numbers go
           from first item (0) to last item ($count-1), and negative numbers go
           from last item (-1) to first item (-$count). Where $count is
           the number of items currently in the container.

           If $index is less than -$count, it will return the first item
           whereas $index greater than $count-1 will return the last item.
         ]]
         params {
            @in index: int; [[Index of the item to retrieve.
                              Valid range is -$count to ($count-1).
                            ]]
         }
         return: Efl.Gfx.Entity; [[The object contained at the given $index.]]
      }
      pack_index_get {
         [[Get the index of a child in this container.]]
         params {
            @in subobj: const(Efl.Gfx.Entity); [[An object contained in this pack.]]
         }
         return: int(-1); [[-1 in case $subobj is not a child of this object,
                            or the index of this item in the range 0 to ($count-1).
                          ]]
      }
      pack_unpack_at {
         [[Pop out (remove) the item at the specified $index.

           $index ranges from -$count to $count-1, where positive numbers go
           from first item (0) to last item ($count-1), and negative numbers go
           from last item (-1) to first item (-$count). Where $count is
           the number of items currently in the container.

           If $index is less than -$count, it will remove the first item
           whereas $index greater than $count-1 will remove the last item.

           Equivalent to @Efl.Pack.unpack(@.pack_content_get($index)).
         ]]
         params {
            @in index: int; [[Index of item to remove.
                              Valid range is -$count to ($count-1).
                            ]]
         }
         return: Efl.Gfx.Entity; [[The child item if it could be removed.]]
      }
   }
}
